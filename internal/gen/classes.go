// Code generated by wazero-emscripten-embind, DO NOT EDIT.
package gen

import (
	"context"

	"github.com/jerbob92/wazero-emscripten-embind"
)

type ClassByteView struct {
	embind.ClassBase
}

func (class *ClassByteView) Clone(ctx context.Context) (*ClassByteView, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassByteView), nil
}

func (class *ClassByteView) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassByteView) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassByteView) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassByteView) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassByteView) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassByteView) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassByteView) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassByteView) Data(ctx context.Context) (any, error) {
	res, err := class.CallMethod(ctx, "data")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func NewClassByteView(e embind.Engine, ctx context.Context, arg0 uint32) (*ClassByteView, error) {
	res, err := e.CallPublicSymbol(ctx, "ByteView", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassByteView), nil
}

type ClassOCREngine struct {
	embind.ClassBase
}

func (class *ClassOCREngine) Clone(ctx context.Context) (*ClassOCREngine, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassOCREngine), nil
}

func (class *ClassOCREngine) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassOCREngine) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassOCREngine) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassOCREngine) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassOCREngine) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassOCREngine) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassOCREngine) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassOCREngine) ClearImage(ctx context.Context) error {
	_, err := class.CallMethod(ctx, "clearImage")
	return err
}

func (class *ClassOCREngine) GetBoundingBoxes(ctx context.Context, arg0 EnumTextUnit) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "getBoundingBoxes", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassOCREngine) GetHOCR(ctx context.Context, arg0 any) (string, error) {
	res, err := class.CallMethod(ctx, "getHOCR", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassOCREngine) GetOrientation(ctx context.Context) (map[string]any, error) {
	res, err := class.CallMethod(ctx, "getOrientation")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(map[string]any), nil
}

func (class *ClassOCREngine) GetText(ctx context.Context, arg0 any) (string, error) {
	res, err := class.CallMethod(ctx, "getText", arg0)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassOCREngine) GetTextBoxes(ctx context.Context, arg0 EnumTextUnit, arg1 any) (embind.ClassBase, error) {
	res, err := class.CallMethod(ctx, "getTextBoxes", arg0, arg1)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(embind.ClassBase), nil
}

func (class *ClassOCREngine) GetVariable(ctx context.Context, arg0 string) (map[string]any, error) {
	res, err := class.CallMethod(ctx, "getVariable", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(map[string]any), nil
}

func (class *ClassOCREngine) LoadImage(ctx context.Context, arg0 embind.ClassBase, arg1 bool) (string, error) {
	res, err := class.CallMethod(ctx, "loadImage", arg0, arg1)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassOCREngine) LoadModel(ctx context.Context, arg0 embind.ClassBase, arg1 string) (string, error) {
	res, err := class.CallMethod(ctx, "loadModel", arg0, arg1)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func (class *ClassOCREngine) SetVariable(ctx context.Context, arg0 string, arg1 string) (string, error) {
	res, err := class.CallMethod(ctx, "setVariable", arg0, arg1)
	if err != nil {
		return "", err
	}

	if res == nil {
		return "", nil
	}

	return res.(string), nil
}

func NewClassOCREngine(e embind.Engine, ctx context.Context) (*ClassOCREngine, error) {
	res, err := e.CallPublicSymbol(ctx, "OCREngine")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassOCREngine), nil
}

type ClassVector_IntRect_ struct {
	embind.ClassBase
}

func (class *ClassVector_IntRect_) Clone(ctx context.Context) (*ClassVector_IntRect_, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVector_IntRect_), nil
}

func (class *ClassVector_IntRect_) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVector_IntRect_) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVector_IntRect_) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVector_IntRect_) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVector_IntRect_) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVector_IntRect_) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVector_IntRect_) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVector_IntRect_) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVector_IntRect_) Push_back(ctx context.Context, arg0 map[string]any) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVector_IntRect_) Resize(ctx context.Context, arg0 uint32, arg1 map[string]any) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVector_IntRect_) Set(ctx context.Context, arg0 uint32, arg1 map[string]any) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVector_IntRect_) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVector_IntRect_(e embind.Engine, ctx context.Context) (*ClassVector_IntRect_, error) {
	res, err := e.CallPublicSymbol(ctx, "vector_IntRect_")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVector_IntRect_), nil
}

type ClassVector_TextRect_ struct {
	embind.ClassBase
}

func (class *ClassVector_TextRect_) Clone(ctx context.Context) (*ClassVector_TextRect_, error) {
	res, err := class.CloneInstance(ctx, class)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	return res.(*ClassVector_TextRect_), nil
}

func (class *ClassVector_TextRect_) Delete(ctx context.Context) error {
	return class.DeleteInstance(ctx, class)
}

func (class *ClassVector_TextRect_) DeleteLater(ctx context.Context) (embind.ClassBase, error) {
	return class.DeleteInstanceLater(ctx, class)
}

func (class *ClassVector_TextRect_) IsDeleted(ctx context.Context) bool {
	return class.IsInstanceDeleted(ctx, class)
}

func (class *ClassVector_TextRect_) IsAliasOf(ctx context.Context, second embind.ClassBase) (bool, error) {
	return class.IsAliasOfInstance(ctx, class, second)
}

func (class *ClassVector_TextRect_) CallMethod(ctx context.Context, name string, arguments ...any) (any, error) {
	return class.CallInstanceMethod(ctx, class, name, arguments...)
}

func (class *ClassVector_TextRect_) SetProperty(ctx context.Context, name string, value any) error {
	return class.SetInstanceProperty(ctx, class, name, value)
}

func (class *ClassVector_TextRect_) GetProperty(ctx context.Context, name string) (any, error) {
	return class.GetInstanceProperty(ctx, class, name)
}

func (class *ClassVector_TextRect_) Get(ctx context.Context, arg0 uint32) (any, error) {
	res, err := class.CallMethod(ctx, "get", arg0)
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(any), nil
}

func (class *ClassVector_TextRect_) Push_back(ctx context.Context, arg0 map[string]any) error {
	_, err := class.CallMethod(ctx, "push_back", arg0)
	return err
}

func (class *ClassVector_TextRect_) Resize(ctx context.Context, arg0 uint32, arg1 map[string]any) error {
	_, err := class.CallMethod(ctx, "resize", arg0, arg1)
	return err
}

func (class *ClassVector_TextRect_) Set(ctx context.Context, arg0 uint32, arg1 map[string]any) (bool, error) {
	res, err := class.CallMethod(ctx, "set", arg0, arg1)
	if err != nil {
		return bool(false), err
	}

	if res == nil {
		return bool(false), nil
	}

	return res.(bool), nil
}

func (class *ClassVector_TextRect_) Size(ctx context.Context) (uint32, error) {
	res, err := class.CallMethod(ctx, "size")
	if err != nil {
		return uint32(0), err
	}

	if res == nil {
		return uint32(0), nil
	}

	return res.(uint32), nil
}

func NewClassVector_TextRect_(e embind.Engine, ctx context.Context) (*ClassVector_TextRect_, error) {
	res, err := e.CallPublicSymbol(ctx, "vector_TextRect_")
	if err != nil {
		return nil, err
	}

	if res == nil {
		return nil, nil
	}

	return res.(*ClassVector_TextRect_), nil
}
